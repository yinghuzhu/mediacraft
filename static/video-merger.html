<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MediaCraft - Professional Video Merger Tool</title>
    <meta name="description" content="MediaCraft offers intelligent video merging with precise time segment selection. Combine multiple videos easily while preserving quality. Supports MP4, MOV, AVI, MKV formats.">
    <meta name="keywords" content="MediaCraft, video merger, video combiner, video editing tools, video concatenation, online video editing, professional video tools, merge videos">
    <meta property="og:title" content="MediaCraft - Professional Video Merger Tool">
    <meta property="og:description" content="Combine multiple videos with precise time segment selection. Powered by advanced technology.">
    <meta property="og:url" content="https://mediacraft.yzhu.name/video-merger.html">
    <meta property="og:type" content="website">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="MediaCraft - Professional Video Merger Tool">
    <meta name="twitter:description" content="Combine multiple videos with precise time segment selection. Powered by advanced technology.">

    <!-- Bootstrap 5 CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha3/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Bootstrap Icons -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css">

    <!-- SortableJS for drag-and-drop -->
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js"></script>

    <style>
        .upload-area {
            border: 2px dashed #dee2e6;
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
        }
        .upload-area:hover, .upload-area.dragover {
            border-color: #0d6efd;
            background-color: #f8f9ff;
        }
        .video-item {
            border: 1px solid #dee2e6;
            border-radius: 8px;
            margin-bottom: 15px;
            padding: 15px;
            transition: all 0.3s ease;
        }
        .video-item:hover {
            box-shadow: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.075);
        }
        .video-item.dragging {
            opacity: 0.5;
            border: 2px dashed #0d6efd;
        }
        .sortable-ghost {
            opacity: 0.4;
            background-color: #f0f8ff;
        }
        .video-preview {
            width: 100%;
            height: auto;
            max-height: 150px;
            object-fit: cover;
            border-radius: 4px;
        }
        .time-slider {
            width: 100%;
        }
        .step-indicator {
            display: flex;
            justify-content: center;
            margin-bottom: 30px;
        }
        .step {
            display: flex;
            align-items: center;
            margin: 0 10px;
        }
        .step-number {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background-color: #6c757d;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 8px;
            font-weight: bold;
        }
        .step.active .step-number {
            background-color: #0d6efd;
        }
        .step.completed .step-number {
            background-color: #198754;
        }
        body {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        main {
            flex: 1;
        }
        .header-title {
            font-size: 1.5rem;
            font-weight: 500;
        }
        
        /* Loading button styles */
        .btn.loading {
            position: relative;
            pointer-events: none;
        }
        
        .btn.loading:hover {
            cursor: not-allowed;
        }
        
        /* Disable interactions during request */
        body.request-in-progress .upload-area,
        .upload-area.disabled {
            pointer-events: none;
            opacity: 0.6;
        }
        
        /* Loading overlay for sections */
        .section-loading {
            position: relative;
            opacity: 0.6;
            pointer-events: none;
        }
        
        .section-loading::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        /* Drag handle */
        .drag-handle {
            cursor: move;
            color: #6c757d;
        }
        
        /* Mobile optimizations */
        @media (max-width: 768px) {
            .video-item {
                padding: 10px;
            }
            .video-controls {
                flex-direction: column;
            }
            .time-inputs {
                margin-top: 10px;
            }
            .btn-group {
                flex-direction: column;
            }
            .btn-group .btn {
                border-radius: 0.375rem !important;
                margin-bottom: 2px;
            }
            .step-indicator {
                flex-wrap: wrap;
            }
            .step {
                margin: 5px;
                font-size: 0.9rem;
            }
            .upload-area {
                padding: 20px;
            }
            .card-body .row {
                flex-direction: column;
            }
            .card-body .row > div {
                margin-bottom: 10px;
            }
        }
        
        /* Touch-friendly improvements */
        @media (max-width: 768px) and (pointer: coarse) {
            .btn {
                min-height: 44px;
                padding: 0.5rem 1rem;
            }
            .form-control {
                min-height: 44px;
            }
            .drag-handle {
                font-size: 1.2rem;
                padding: 10px;
            }
        }
    </style>
</head>
<body>
    <header class="bg-light p-3 border-bottom">
        <div class="container">
            <div class="d-flex align-items-center justify-content-between">
                <div class="d-flex align-items-center">
                    <img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0MCIgaGVpZ2h0PSI0MCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9IiMwZDZlZmQiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIj48cGF0aCBkPSJNMTIgMnYyMCIvPjxwYXRoIGQ9Ik0xNyA1SDlsLTIgNSAyIDUgNCAyIDQtMiAyLTUtMi01eiIvPjwvc3ZnPg==" alt="MediaCraft Logo" width="40" height="40" class="me-2">
                    <h1 class="header-title m-0">MediaCraft</h1>
                </div>
                <div class="d-flex">
                    <a href="/" class="btn btn-outline-primary me-2">Video Watermark Remover</a>
                    <a href="/video-merger.html" class="btn btn-primary">Video Merger</a>
                </div>
            </div>
        </div>
    </header>

    <main class="container my-5">
        <!-- Introduction Section -->
        <div class="card mb-4">
            <div class="card-body">
                <div class="row align-items-center">
                    <div class="col-md-7">
                        <h2>Professional Video Merger</h2>
                        <p class="lead">Combine multiple videos into one seamless file with precise time segment control.</p>
                        <p>MediaCraft's advanced video merger allows you to select specific segments from each video and combine them in any order. Perfect for content creators, marketers, and video professionals who need to create compilations or montages.</p>
                        <div class="d-flex flex-wrap gap-2 mt-3">
                            <div class="badge bg-light text-dark p-2"><i class="bi bi-check-circle text-success me-1"></i> Multiple Video Support</div>
                            <div class="badge bg-light text-dark p-2"><i class="bi bi-check-circle text-success me-1"></i> Precise Time Selection</div>
                            <div class="badge bg-light text-dark p-2"><i class="bi bi-check-circle text-success me-1"></i> Custom Order Arrangement</div>
                            <div class="badge bg-light text-dark p-2"><i class="bi bi-check-circle text-success me-1"></i> High Quality Output</div>
                        </div>
                    </div>
                    <div class="col-md-5 mt-3 mt-md-0 text-center">
                        <img src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMDAiIGhlaWdodD0iMjAwIiB2aWV3Qm94PSIwIDAgMjQgMjQiIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzBkNmVmZCIgc3Ryb2tlLXdpZHRoPSIxLjUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCI+PHJlY3QgeD0iMiIgeT0iMiIgd2lkdGg9IjIwIiBoZWlnaHQ9IjIwIiByeD0iMi41IiByeT0iMi41Ij48L3JlY3Q+PGxpbmUgeDE9IjciIHkxPSIyIiB4Mj0iNyIgeTI9IjIyIj48L2xpbmU+PGxpbmUgeDE9IjE3IiB5MT0iMiIgeDI9IjE3IiB5Mj0iMjIiPjwvbGluZT48bGluZSB4MT0iMiIgeTE9IjEyIiB4Mj0iMjIiIHkyPSIxMiI+PC9saW5lPjxsaW5lIHgxPSIyIiB5MT0iNyIgeDI9IjciIHkyPSI3Ij48L2xpbmU+PGxpbmUgeDE9IjIiIHkxPSIxNyIgeDI9IjciIHkyPSIxNyI+PC9saW5lPjxsaW5lIHgxPSIxNyIgeTE9IjE3IiB4Mj0iMjIiIHkyPSIxNyI+PC9saW5lPjxsaW5lIHgxPSIxNyIgeTE9IjciIHgyPSIyMiIgeTI9IjciPjwvbGluZT48Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSIzIj48L2NpcmNsZT48bGluZSB4MT0iMTAiIHkxPSI3IiB4Mj0iMTQiIHkyPSI3IiBzdHJva2U9IiMwZDZlZmQiIHN0cm9rZS13aWR0aD0iMiI+PC9saW5lPjwvc3ZnPg==" alt="Video Merger Illustration" class="img-fluid" style="max-width: 200px;">
                    </div>
                </div>
            </div>
        </div>

        <!-- Step Indicator -->
        <div class="step-indicator">
            <div class="step active" id="step-upload">
                <div class="step-number">1</div>
                <span>Upload Videos</span>
            </div>
            <div class="step" id="step-edit">
                <div class="step-number">2</div>
                <span>Edit Segments</span>
            </div>
            <div class="step" id="step-arrange">
                <div class="step-number">3</div>
                <span>Arrange Order</span>
            </div>
            <div class="step" id="step-process">
                <div class="step-number">4</div>
                <span>Process Complete</span>
            </div>
        </div>

        <!-- Alert Container -->
        <div id="alert-container"></div>

        <!-- Task Creation Section -->
        <div id="task-section" class="card mb-4">
            <div class="card-header">
                <h5 class="mb-0">Create Merge Task</h5>
            </div>
            <div class="card-body">
                <div class="mb-3">
                    <label for="task-name" class="form-label">Task Name</label>
                    <input type="text" class="form-control" id="task-name" placeholder="My Video Compilation">
                </div>
                <div class="row">
                    <div class="col-md-4 mb-3">
                        <label for="merge-mode" class="form-label">Merge Mode</label>
                        <select class="form-select" id="merge-mode">
                            <option value="concat" selected>Simple Concatenation</option>
                            <option value="blend" disabled>Smooth Transition (Coming Soon)</option>
                        </select>
                    </div>
                    <div class="col-md-4 mb-3">
                        <label for="audio-handling" class="form-label">Audio Handling</label>
                        <select class="form-select" id="audio-handling">
                            <option value="keep_all" selected>Keep All Audio</option>
                            <option value="keep_first">Keep First Video's Audio Only</option>
                            <option value="remove">Remove All Audio</option>
                        </select>
                    </div>
                    <div class="col-md-4 mb-3">
                        <label for="quality-preset" class="form-label">Quality Preset</label>
                        <select class="form-select" id="quality-preset">
                            <option value="fast">Fast (Lower Quality)</option>
                            <option value="medium" selected>Medium (Balanced)</option>
                            <option value="high">High (Best Quality)</option>
                        </select>
                    </div>
                </div>
                <button class="btn btn-primary" id="create-task-btn">Create Task</button>
            </div>
        </div>

        <!-- Main Application Section -->
        <div id="app-section" class="d-none">
            <!-- Upload Section -->
            <div id="upload-section" class="card mb-4">
                <div class="card-header">
                    <h5 class="mb-0">Step 1: Upload Your Videos</h5>
                </div>
                <div class="card-body">
                    <div id="upload-area" class="upload-area">
                        <i class="bi bi-cloud-arrow-up-fill fs-1 text-muted"></i>
                        <p class="mb-0">Drag & drop video files here, or click to select files.</p>
                        <p class="text-muted small">Max 10 files, up to 500MB each.</p>
                    </div>
                    <input type="file" id="file-input" multiple class="d-none" accept="video/mp4,video/quicktime,video/x-msvideo,video/x-matroska">
                </div>
            </div>

            <!-- Video List Section -->
            <div id="video-list-section" class="card mb-4">
                <div class="card-header">
                    <h5 class="mb-0">Step 2: Edit & Arrange Videos</h5>
                </div>
                <div class="card-body">
                    <div id="video-list" class="mb-3">
                        <!-- Video items will be injected here by JavaScript -->
                    </div>
                    <div id="merge-controls" class="d-flex justify-content-end">
                        <button class="btn btn-success btn-lg" id="start-merge-btn" disabled>
                            <i class="bi bi-film me-2"></i>Start Merging
                        </button>
                    </div>
                </div>
            </div>

            <!-- Processing Section -->
            <div id="processing-section" class="card mb-4 d-none">
                <div class="card-header">
                    <h5 class="mb-0">Step 3: Processing Your Video</h5>
                </div>
                <div class="card-body text-center">
                    <div id="progress-bar" class="progress mb-3" style="height: 25px;">
                        <div class="progress-bar progress-bar-striped progress-bar-animated" role="progressbar" style="width: 0%;" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">0%</div>
                    </div>
                    <p id="progress-status-text" class="lead">Your video is being processed. Please wait...</p>
                </div>
            </div>

            <!-- Download Section -->
            <div id="download-section" class="card mb-4 d-none">
                <div class="card-header">
                    <h5 class="mb-0">Step 4: Download Your Merged Video</h5>
                </div>
                <div class="card-body text-center">
                    <h4 id="download-task-name"></h4>
                    <p>Your video has been successfully merged and is ready for download.</p>
                    <a href="#" id="download-btn" class="btn btn-primary btn-lg">
                        <i class="bi bi-download me-2"></i>Download Video
                    </a>
                </div>
            </div>

        </div>

    </main>

    <footer class="bg-light text-center text-muted p-3 mt-auto">
        <div class="container">
            &copy; 2024 MediaCraft. All Rights Reserved.
        </div>
    </footer>
    
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // State management
            let state = {
                task_uuid: null,
                task_name: '',
                items: [],
                statusPollInterval: null,
            };

            // --- Element Selectors ---
            const createTaskBtn = document.getElementById('create-task-btn');
            const taskSection = document.getElementById('task-section');
            const appSection = document.getElementById('app-section');
            const uploadArea = document.getElementById('upload-area');
            const fileInput = document.getElementById('file-input');
            const videoList = document.getElementById('video-list');
            const startMergeBtn = document.getElementById('start-merge-btn');
            const processingSection = document.getElementById('processing-section');
            const downloadSection = document.getElementById('download-section');
            const progressBar = document.querySelector('#progress-bar .progress-bar');
            const progressStatusText = document.getElementById('progress-status-text');
            const downloadBtn = document.getElementById('download-btn');
            const downloadTaskName = document.getElementById('download-task-name');
            const alertContainer = document.getElementById('alert-container');

            // --- API Functions ---
            const api = {
                createTask: async (taskName, options) => {
                    const response = await fetch('/api/video/merge/create', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ task_name: taskName, ...options }),
                    });
                    return response.json();
                },
                uploadFile: (task_uuid, file, onProgress) => {
                    return new Promise((resolve, reject) => {
                        const formData = new FormData();
                        formData.append('task_uuid', task_uuid);
                        formData.append('file', file);

                        const xhr = new XMLHttpRequest();
                        xhr.open('POST', '/api/video/merge/upload', true);

                        xhr.upload.onprogress = (event) => {
                            if (event.lengthComputable) {
                                const percentComplete = Math.round((event.loaded / event.total) * 100);
                                onProgress(percentComplete);
                            }
                        };

                        xhr.onload = () => {
                            if (xhr.status >= 200 && xhr.status < 300) {
                                resolve(JSON.parse(xhr.responseText));
                            } else {
                                reject(JSON.parse(xhr.responseText));
                            }
                        };

                        xhr.onerror = () => reject(xhr.statusText);
                        xhr.send(formData);
                    });
                },
                updateItem: async (task_uuid, item_id, data) => {
                    const response = await fetch(`/api/video/merge/task/${task_uuid}/items/${item_id}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(data),
                    });
                    return response.json();
                },
                deleteItem: async (task_uuid, item_id) => {
                    const response = await fetch(`/api/video/merge/task/${task_uuid}/items/${item_id}`, {
                        method: 'DELETE',
                    });
                    return response.json();
                },
                reorderItems: async (task_uuid, itemOrder) => {
                    const response = await fetch(`/api/video/merge/task/${task_uuid}/reorder`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ item_order: itemOrder }),
                    });
                    return response.json();
                },
                startMerge: async (task_uuid) => {
                    const response = await fetch(`/api/video/merge/task/${task_uuid}/start`, {
                        method: 'POST',
                    });
                    return response.json();
                },
                getStatus: async (task_uuid) => {
                    const response = await fetch(`/api/video/merge/task/${task_uuid}/status`);
                    return response.json();
                },
            };

            // --- UI Functions ---
            const ui = {
                showAlert: (message, type = 'danger') => {
                    // Clear previous alerts of the same type to prevent accumulation
                    const existingAlerts = alertContainer.querySelectorAll(`.alert-${type}`);
                    existingAlerts.forEach(alert => {
                        if (alert.textContent.trim() === message) {
                            alert.remove();
                        }
                    });
                    
                    const wrapper = document.createElement('div');
                    wrapper.innerHTML = [
                        `<div class="alert alert-${type} alert-dismissible" role="alert">`,
                        `   <div>${message}</div>`,
                        '   <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>',
                        '</div>'
                    ].join('');
                    alertContainer.append(wrapper);
                    
                    // Auto-dismiss success messages after 3 seconds
                    if (type === 'success') {
                        setTimeout(() => {
                            const alertElement = wrapper.querySelector('.alert');
                            if (alertElement && alertElement.parentNode) {
                                alertElement.remove();
                            }
                        }, 3000);
                    }
                },
                clearAlerts: () => {
                    // Ensure all alerts are removed
                    alertContainer.innerHTML = '';
                    
                    // Also remove any alerts that might be outside the container
                    document.querySelectorAll('.alert').forEach(alert => {
                        if (alert.parentElement !== alertContainer) {
                            alert.remove();
                        }
                    });
                },
                setLoading: (element, isLoading) => {
                    if (isLoading) {
                        element.classList.add('loading');
                        element.disabled = true;
                    } else {
                        element.classList.remove('loading');
                        element.disabled = false;
                    }
                },
                renderVideoItem: (item) => {
                    const duration = (item.video_duration && typeof item.video_duration === 'number') ? item.video_duration.toFixed(1) : '0.0';
                    const segmentDuration = (item.segment_duration && typeof item.segment_duration === 'number') ? item.segment_duration.toFixed(1) : duration;

                    const div = document.createElement('div');
                    div.className = 'video-item card';
                    div.dataset.itemId = item.item_id;
                    div.innerHTML = `
                        <div class="card-body">
                            <div class="row align-items-center">
                                <div class="col-auto drag-handle"><i class="bi bi-grip-vertical"></i></div>
                                <div class="col-md-3">
                                    <h6 class="mb-1">${item.original_filename}</h6>
                                    <small class="text-muted">
                                        Duration: ${duration}s | Resolution: ${item.video_resolution || 'N/A'}
                                    </small>
                                    <div class="mt-1">
                                        <small class="badge bg-info">Segment: ${segmentDuration}s</small>
                                    </div>
                                </div>
                                <div class="col-md-6 video-controls">
                                    <div class="row">
                                        <div class="col-md-6 mb-2">
                                            <label class="form-label small">Start Time (s)</label>
                                            <input type="number" class="form-control start-time" value="${(item.start_time || 0).toFixed(1)}" min="0" max="${duration}" step="0.1">
                                        </div>
                                        <div class="col-md-6 mb-2">
                                            <label class="form-label small">End Time (s)</label>
                                            <input type="number" class="form-control end-time" value="${(item.end_time || parseFloat(duration) || 0).toFixed(1)}" min="0" max="${duration}" step="0.1">
                                        </div>
                                    </div>
                                    <div class="d-flex gap-2">
                                        <button class="btn btn-outline-primary btn-sm update-time-btn" type="button">
                                            <i class="bi bi-check"></i> Update
                                        </button>
                                        <button class="btn btn-outline-secondary btn-sm reset-time-btn" type="button">
                                            <i class="bi bi-arrow-clockwise"></i> Reset
                                        </button>
                                    </div>
                                </div>
                                <div class="col-md-3 text-end">
                                    <div class="btn-group" role="group">
                                        <button class="btn btn-outline-secondary btn-sm move-up-btn" type="button" title="Move Up">
                                            <i class="bi bi-arrow-up"></i>
                                        </button>
                                        <button class="btn btn-outline-secondary btn-sm move-down-btn" type="button" title="Move Down">
                                            <i class="bi bi-arrow-down"></i>
                                        </button>
                                        <button class="btn btn-danger btn-sm delete-item-btn" type="button" title="Delete">
                                            <i class="bi bi-trash"></i>
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="progress" style="height: 5px; display: none;">
                            <div class="progress-bar" role="progressbar" style="width: 0%;"></div>
                        </div>
                    `;
                    videoList.appendChild(div);
                },
                renderVideoList: () => {
                    videoList.innerHTML = '';
                    state.items.forEach(item => ui.renderVideoItem(item));
                    startMergeBtn.disabled = state.items.length === 0;
                    
                    // Update total duration display
                    ui.updateTotalDuration();
                },
                updateTotalDuration: () => {
                    const totalDuration = state.items.reduce((sum, item) => sum + (item.segment_duration || 0), 0);
                    const totalMinutes = Math.floor(totalDuration / 60);
                    const totalSeconds = (totalDuration % 60).toFixed(1);
                    
                    let durationText = '';
                    if (totalMinutes > 0) {
                        durationText = `${totalMinutes}m ${totalSeconds}s`;
                    } else {
                        durationText = `${totalSeconds}s`;
                    }
                    
                    // Update or create duration display
                    let durationDisplay = document.getElementById('total-duration-display');
                    if (!durationDisplay) {
                        durationDisplay = document.createElement('div');
                        durationDisplay.id = 'total-duration-display';
                        durationDisplay.className = 'alert alert-info mb-3';
                        document.getElementById('merge-controls').parentNode.insertBefore(durationDisplay, document.getElementById('merge-controls'));
                    }
                    
                    durationDisplay.innerHTML = `
                        <div class="d-flex justify-content-between align-items-center">
                            <div>
                                <strong>Total Videos:</strong> ${state.items.length} | 
                                <strong>Total Duration:</strong> ${durationText}
                            </div>
                            <div>
                                <small class="text-muted">Ready to merge</small>
                            </div>
                        </div>
                    `;
                },
                updateProgress: (status) => {
                    progressBar.style.width = `${status.progress_percentage}%`;
                    progressBar.textContent = `${status.progress_percentage}%`;
                    progressBar.setAttribute('aria-valuenow', status.progress_percentage);
                    progressStatusText.textContent = `Status: ${status.status}...`;
                },
                showDownload: (task) => {
                    processingSection.classList.add('d-none');
                    downloadSection.classList.remove('d-none');
                    downloadTaskName.textContent = task.task_name;
                    downloadBtn.href = `/api/video/merge/task/${task.task_uuid}/download`;
                },
                moveItem: async (item_id, direction) => {
                    const currentIndex = state.items.findIndex(i => i.item_id === item_id);
                    if (currentIndex === -1) return;
                    
                    let newIndex;
                    if (direction === 'up' && currentIndex > 0) {
                        newIndex = currentIndex - 1;
                    } else if (direction === 'down' && currentIndex < state.items.length - 1) {
                        newIndex = currentIndex + 1;
                    } else {
                        return; // Can't move
                    }
                    
                    // Swap items in array
                    [state.items[currentIndex], state.items[newIndex]] = [state.items[newIndex], state.items[currentIndex]];
                    
                    // Update order numbers
                    state.items.forEach((item, index) => {
                        item.item_order = index + 1;
                    });
                    
                    // Get new order
                    const itemOrder = state.items.map(item => item.item_id);
                    
                    // API call to save new order
                    const result = await api.reorderItems(state.task_uuid, itemOrder);
                    if (result.code === 10000) {
                        ui.renderVideoList();
                        ui.showAlert('Video order updated!', 'success');
                    } else {
                        ui.showAlert('Failed to save new order. Please try again.');
                        // Revert the change
                        [state.items[currentIndex], state.items[newIndex]] = [state.items[newIndex], state.items[currentIndex]];
                        ui.renderVideoList();
                    }
                }
            };
            
            // --- Event Handlers ---
            createTaskBtn.addEventListener('click', async () => {
                const taskNameInput = document.getElementById('task-name');
                const taskName = taskNameInput.value || 'Untitled Merge';
                const options = {
                    merge_mode: document.getElementById('merge-mode').value,
                    audio_handling: document.getElementById('audio-handling').value,
                    quality_preset: document.getElementById('quality-preset').value,
                };

                ui.setLoading(createTaskBtn, true);
                try {
                    const result = await api.createTask(taskName, options);
                    if (result.code === 10000) {
                        state.task_uuid = result.data.task_uuid;
                        state.task_name = result.data.task_name;
                        taskSection.classList.add('d-none');
                        appSection.classList.remove('d-none');
                    } else {
                        ui.showAlert(result.message);
                    }
                } catch (error) {
                    ui.showAlert('Failed to create task. Please try again.');
                } finally {
                    ui.setLoading(createTaskBtn, false);
                }
            });

            uploadArea.addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', (e) => handleFiles(e.target.files));
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                uploadArea.addEventListener(eventName, preventDefaults, false);
            });
            ['dragenter', 'dragover'].forEach(eventName => {
                uploadArea.addEventListener(eventName, () => uploadArea.classList.add('dragover'), false);
            });
            ['dragleave', 'drop'].forEach(eventName => {
                uploadArea.addEventListener(eventName, () => uploadArea.classList.remove('dragover'), false);
            });
            uploadArea.addEventListener('drop', (e) => handleFiles(e.dataTransfer.files), false);
            
            videoList.addEventListener('click', async (e) => {
                const target = e.target;
                const videoItem = target.closest('.video-item');
                if (!videoItem) return;

                const item_id = videoItem.dataset.itemId;

                if (target.closest('.delete-item-btn')) {
                    if (confirm('Are you sure you want to delete this video?')) {
                        const result = await api.deleteItem(state.task_uuid, item_id);
                        if (result.code === 10000) {
                            state.items = state.items.filter(i => i.item_id !== item_id);
                            ui.renderVideoList();
                            ui.showAlert('Video deleted successfully!', 'success');
                        } else {
                            ui.showAlert(result.message);
                        }
                    }
                } else if (target.closest('.update-time-btn')) {
                    const startTimeInput = videoItem.querySelector('.start-time');
                    const endTimeInput = videoItem.querySelector('.end-time');
                    const startTime = parseFloat(startTimeInput.value);
                    const endTime = parseFloat(endTimeInput.value);
                    
                    // Get the current item to check against video duration
                    const currentItem = state.items.find(i => i.item_id === item_id);
                    if (!currentItem) {
                        ui.showAlert('Item not found', 'danger');
                        return;
                    }
                    
                    // Validate time values
                    if (isNaN(startTime) || isNaN(endTime)) {
                        ui.showAlert('Invalid time values: must be numbers', 'danger');
                        return;
                    }
                    
                    if (startTime < 0) {
                        ui.showAlert('Start time cannot be negative', 'danger');
                        startTimeInput.value = 0;
                        return;
                    }
                    
                    if (startTime >= endTime) {
                        ui.showAlert('Start time must be less than end time', 'danger');
                        return;
                    }
                    
                    if (endTime > currentItem.video_duration) {
                        ui.showAlert(`End time cannot exceed video duration (${currentItem.video_duration.toFixed(1)}s)`, 'danger');
                        endTimeInput.value = currentItem.video_duration.toFixed(1);
                        return;
                    }
                    
                    try {
                        const result = await api.updateItem(state.task_uuid, item_id, { start_time: startTime, end_time: endTime });
                        if(result.code === 10000) {
                            const updatedItem = result.data;
                            const index = state.items.findIndex(i => i.item_id === item_id);
                            if (index !== -1) state.items[index] = updatedItem;
                            
                            // Update UI without showing multiple alerts
                            const segmentDuration = (updatedItem.end_time - updatedItem.start_time).toFixed(1);
                            const durationBadge = videoItem.querySelector('.badge.bg-info');
                            if (durationBadge) {
                                durationBadge.textContent = `Segment: ${segmentDuration}s`;
                            }
                            
                            ui.updateTotalDuration();
                            ui.showAlert(`Time segment updated successfully`, 'success');
                        } else {
                            ui.showAlert(result.message, 'danger');
                        }
                    } catch (error) {
                        ui.showAlert(`Failed to update time segment: ${error.message}`, 'danger');
                    }
                } else if (target.closest('.reset-time-btn')) {
                    const item = state.items.find(i => i.item_id === item_id);
                    if (item) {
                        const result = await api.updateItem(state.task_uuid, item_id, { 
                            start_time: 0, 
                            end_time: item.video_duration 
                        });
                        if(result.code === 10000) {
                            const updatedItem = result.data;
                            const index = state.items.findIndex(i => i.item_id === item_id);
                            if (index !== -1) state.items[index] = updatedItem;
                            ui.renderVideoList();
                            ui.showAlert(`Time segment reset for ${updatedItem.original_filename}!`, 'success');
                        } else {
                            ui.showAlert(result.message);
                        }
                    }
                } else if (target.closest('.move-up-btn')) {
                    ui.moveItem(item_id, 'up');
                } else if (target.closest('.move-down-btn')) {
                    ui.moveItem(item_id, 'down');
                }
            });

            startMergeBtn.addEventListener('click', async () => {
                // Prevent multiple clicks
                if (startMergeBtn.disabled) return;
                
                // Clear ALL previous alerts
                ui.clearAlerts();
                
                // Validate all time segments before starting
                let hasInvalidSegments = false;
                for (const item of state.items) {
                    if (item.start_time < 0 || item.end_time <= item.start_time || 
                        item.end_time > item.video_duration) {
                        hasInvalidSegments = true;
                        ui.showAlert(`Invalid time segment for "${item.original_filename}": Start=${item.start_time}s, End=${item.end_time}s`, 'warning');
                    }
                }
                
                if (hasInvalidSegments) {
                    ui.showAlert('Please fix invalid time segments before starting the merge process', 'danger');
                    return;
                }
                
                startMergeBtn.disabled = true;
                startMergeBtn.innerHTML = '<i class="bi bi-hourglass-split me-2"></i>Starting...';
                
                try {
                    const result = await api.startMerge(state.task_uuid);
                    if (result.code === 10000) {
                        // Hide all sections except processing
                        document.getElementById('upload-section').classList.add('d-none');
                        document.getElementById('video-list-section').classList.add('d-none');
                        processingSection.classList.remove('d-none');
                        startStatusPolling();
                    } else {
                        ui.showAlert(result.message);
                        startMergeBtn.disabled = false;
                        startMergeBtn.innerHTML = '<i class="bi bi-film me-2"></i>Start Merging';
                    }
                } catch (error) {
                    ui.showAlert('Failed to start merge process: ' + error.message);
                    startMergeBtn.disabled = false;
                    startMergeBtn.innerHTML = '<i class="bi bi-film me-2"></i>Start Merging';
                }
            });

            // --- Logic ---
            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }

            function handleFiles(files) {
                // Validate files before uploading
                const validFiles = [];
                const allowedTypes = ['video/mp4', 'video/quicktime', 'video/x-msvideo', 'video/x-matroska'];
                const maxFileSize = 500 * 1024 * 1024; // 500MB
                const maxFiles = 10;
                
                if (state.items.length + files.length > maxFiles) {
                    ui.showAlert(`Maximum ${maxFiles} videos allowed. You can upload ${maxFiles - state.items.length} more.`);
                    return;
                }
                
                for (let file of files) {
                    if (!allowedTypes.includes(file.type)) {
                        ui.showAlert(`${file.name}: Unsupported format. Please use MP4, MOV, AVI, or MKV.`);
                        continue;
                    }
                    
                    if (file.size > maxFileSize) {
                        ui.showAlert(`${file.name}: File too large. Maximum size is 500MB.`);
                        continue;
                    }
                    
                    validFiles.push(file);
                }
                
                if (validFiles.length === 0) {
                    return;
                }
                
                // Upload valid files
                validFiles.forEach(file => uploadFile(file));
            }

            async function uploadFile(file) {
                const placeholder = document.createElement('div');
                placeholder.className = 'video-item card';
                placeholder.innerHTML = `
                     <div class="card-body">
                        Uploading ${file.name}...
                        <div class="progress mt-2" style="height: 5px;">
                            <div class="progress-bar" role="progressbar" style="width: 0%;"></div>
                        </div>
                    </div>`;
                videoList.appendChild(placeholder);
                const progressBar = placeholder.querySelector('.progress-bar');

                try {
                    const result = await api.uploadFile(state.task_uuid, file, (progress) => {
                        progressBar.style.width = `${progress}%`;
                    });

                    if (result.code === 10000) {
                        // Ensure all required fields are present with defaults
                        const itemData = {
                            ...result.data,
                            video_duration: result.data.video_duration || 0,
                            segment_duration: result.data.segment_duration || result.data.video_duration || 0,
                            start_time: result.data.start_time || 0,
                            end_time: result.data.end_time || result.data.video_duration || 0,
                            video_resolution: result.data.video_resolution || 'N/A',
                            fps: result.data.fps || 0
                        };
                        
                        state.items.push(itemData);
                        placeholder.remove();
                        ui.renderVideoItem(itemData);
                        startMergeBtn.disabled = state.items.length === 0;
                        
                        // Show success message with more details
                        ui.showAlert(`✓ ${file.name} uploaded (${(file.size / (1024*1024)).toFixed(1)}MB)`, 'success');
                        
                        // Re-initialize drag and drop for new items
                        initializeDragAndDrop();
                    } else {
                        ui.showAlert(`Upload failed for ${file.name}: ${result.message}`);
                        placeholder.remove();
                    }
                } catch (error) {
                    ui.showAlert(`Upload failed for ${file.name}: ${error.message || 'Network error'}`);
                    placeholder.remove();
                }
            }

            function startStatusPolling() {
                if (state.statusPollInterval) clearInterval(state.statusPollInterval);

                state.statusPollInterval = setInterval(async () => {
                    if (!state.task_uuid) {
                        clearInterval(state.statusPollInterval);
                        return;
                    }

                    const result = await api.getStatus(state.task_uuid);
                    if (result.code === 10000) {
                        const status = result.data;
                        ui.updateProgress(status);

                        if (status.status === 'completed' || status.status === 'failed') {
                            clearInterval(state.statusPollInterval);
                            if (status.status === 'completed') {
                                ui.showDownload(status);
                            } else {
                                ui.showAlert(`Processing failed: ${status.error_message}`);
                                processingSection.classList.add('d-none');
                                appSection.classList.remove('d-none');
                            }
                        }
                    } else {
                        ui.showAlert('Could not retrieve task status.');
                        clearInterval(state.statusPollInterval);
                    }
                }, 2000);
            }
            
            function initializeDragAndDrop() {
                if (window.sortableInstance) {
                    window.sortableInstance.destroy();
                }
                
                window.sortableInstance = new Sortable(videoList, {
                    animation: 150,
                    handle: '.drag-handle',
                    ghostClass: 'sortable-ghost',
                    onStart: () => {
                        document.body.classList.add('dragging');
                    },
                    onEnd: async (evt) => {
                        document.body.classList.remove('dragging');
                        
                        const itemOrder = [...videoList.querySelectorAll('.video-item')].map(item => item.dataset.itemId);
                        
                        // Reorder state.items array
                        state.items.sort((a, b) => {
                            return itemOrder.indexOf(a.item_id) - itemOrder.indexOf(b.item_id);
                        });

                        // API call to save new order
                        try {
                            const result = await api.reorderItems(state.task_uuid, itemOrder);
                            if (result.code === 10000) {
                                ui.updateTotalDuration();
                                ui.showAlert('Video order updated!', 'success');
                            } else {
                                ui.showAlert('Failed to save new order. Please try again.');
                                // Revert UI if API call fails
                                ui.renderVideoList();
                            }
                        } catch (error) {
                            ui.showAlert('Network error while saving order. Please try again.');
                            ui.renderVideoList();
                        }
                    }
                });
            }
            
            // Add dragging styles
            const style = document.createElement('style');
            style.textContent = `
                .dragging .video-item:not(.sortable-ghost) {
                    opacity: 0.7;
                }
                .sortable-ghost {
                    opacity: 0.4;
                    background-color: #f0f8ff;
                    border: 2px dashed #0d6efd;
                }
            `;
            document.head.appendChild(style);

            // --- Initializer ---
            initializeDragAndDrop();
        });
    </script>
</body>
</html>